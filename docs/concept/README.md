# 前端概念

## polyfill

用于实现浏览器并不支持原生 API 的代码。
下面举一个例子：document.querySelectorAll()现在大多数浏览器都已经支持该方法，但是仍然存在一些比较老的版本的浏览器不支持该方法，此时如果写一个库，通过对该库的引用，从而使得浏览器可以和其他浏览器一样使用该方法，此时这个库就是 polyfill。

### 已经存在的 polyfill

1. polymer:让旧的浏览器可以使用 HTML5 中的 Web Component 的 polyfill。
2. FlushCanvas：是让无法使用的 canvas 的浏览器使用 canvas。

### polyfill 和 shim 的区别:

一个 shim 是一个库，它将一个新的 API 引入到一个旧的环境中，而且仅靠旧环境中已有的手段实现。
一个 polyfill 就是一个用在浏览器 API 上的 shim。

有两大好处

1. 首屏时间缩短
2. 利于 SEO

## urlencoded 编码

对应 get 请求的参数传递格式

```js
"key=value&key=value";
```

## 纯函数

- 同样的输入，得到同样的输出。
- 不得修改传入的参数
- 不调用 Date.now()和 Math.random 等不纯的函数。
- 没有任何副作用，不发送请求等。

## 服务端渲染

SSR (Server-side Rendering)
顾名思义，就是在浏览器发起页面请求后由服务端完成页面的 HTML 结构拼接，返回给浏览器解析后的 HTML，让浏览器能直接构建出有内容的页面。有两个问题：

1. 什么时候开始生成该 HTML，猜测是一旦服务器的服务启动了之后就将该 HTML 生成，而不是等接收到浏览器请求之后再开始生成该 HTML。
2. 服务器端生成的是真实的 html 结构字符串，浏览器直接就可以解析渲染。
3. 浏览器拿到首页 html 之后的执行顺序猜测：直接解析 html 并渲染 -> 根据 html 中的 script 标签下载 js 执行，代码执行后，将页面上的 dom 全部重新替换成由下载的 js 运行后生成的 dom。
4. 服务端渲染框架生成首页 html 的过程猜测为：框架生成对应的真实 html 结构，然后为该 html 添加获取入口 js 的 script 标签。

## 浏览器环境和 node

浏览器的引擎可以解析 js，而 node.js 是谷歌浏览器的 v8 引擎进行封装和优化，使得 js 能够被 node 解析。

## 浏览器

### 工作原理

浏览器在地址栏输入地址后，浏览器向服务器发送了 http 请求，然后返回对应的资源，默认返回 index.html，当该 html 文件加载之后，根据该文件的代码，不断向浏览器请求对应的 css，js，png 等资源，这些资源请求之后被浏览器存储下来并执行。

### 浏览器模块化

- 以前的浏览器的 js 模块化只支持 AMD
- 现代浏览器已经支持了 es 模块化，但是需要将 script 标签的 type 设置为 module，这会将 js 语言环境变为严格模式。
- 如果直接通过盘符打开的 html 文件来使用 es 的模块化语法，会有跨域问题，因为此时浏览器路径是盘符路径，已经和 js 文件所在的盘符地址跨域了。所以需要通过开启本地端口服务器来访问该 html，使 js 文件和 html 文件在同一域下。
- 如果需要访问浏览器 js 引擎模块化需要安装 requre.js 库来实现。

### 浏览器进程与线程

当浏览器新开一个 tab 页之后，会在电脑上开启一个进程，该进程会有协议，域名，端口号，该进程内包括多个线程，iframe 页面也是会新开一个进程。

- GUI 渲染线程，负责渲染页面元素，改线程和 js 引擎是互斥的，当 js 引擎工作时，该线程是不能工作的，这就是 js 运行导致页面阻塞的原因。
- js 引擎，负责解析 js 代码。同样当 GUI 线程工作时，该线程是不工作的。
- 事件触发线程。管理诸如 ajax 请求，setTimeout 等任务。当 js 引擎空闲时会扫描该线程，该线程按照事件循环的规则将任务队列的一个任务推入 js 引擎进行执行。
- 定时器触发器进程。对 setTimeout 和 setInterval 进行计时。当计时达到了将任务推入事件触发线程，等待 js 引擎执行。
- ajax 请求线程。当请求发起时浏览器开启一个线程请求，等待请求返回后将回调任务推入事件触发线程，等待 js 引擎执行。

### 浏览器跨域

一个浏览器进程(tab 页)的 ajax 请求向服务器发送请求获得数据后，浏览器会判断服务器的协议，域名，端口与自己是否一致。如果不一致浏览器则不会将返回的信息提供给我们访问。该限制只在浏览器，在服务器之间发送请求是没有跨域限制的。
解决跨域的方法

1. cors 通过后端返回响应头，浏览器在解析这些响应头后，就会让我们能够访问浏览器得到的数据。
2. jsonp，借助 script 标签的 src 请求，该请求不属于 ajax 请求，不会被同源策略限制，但是只能处理 get 请求。
3. 开启代理服务器，在浏览器所在主机开启一个符合同源策略的代理服务器，ajax 请求发送的时候发送给这台代理服务器，然后代理服务器向目标服务器发送 http 请求，由此我们就可以访问目标服务器返回的数据。
   所以整个数据请求流程变成了：ajax 请求->代理服务器向目标武器发送 http 请求->目标服务器返回对应数据->代理服务器接受到数据->代理服务器将接受的数据提供给浏览器->浏览器提供可供 js 访问的数据。
   开启代理服务器有多种方法

- nginx
- vue-cli 等脚手架。
  配置代理服务器其实就是指设置代理服务器的目标服务器路径，以及将 ajax 请求路径中携带的标识清除以确保代理服务器请求路径和目标服务器对应的资源路径相同等。

### 浏览器源代码

会显示浏览器根据 map 文件反编译生成的代码和实际在 js 引擎中执行的代码。而反编译代码反编译到哪个流程不一致(待研究)，有的情况下反编译至在 node 中运行的代码，有的情况下反编译至开发时源代码。

### 浏览器控制台

编写的代码被浏览器的 js 引擎执行。

### 重绘和回流

- 回流（也叫重排）：当 DOM 结构发生变化 或者 元素样式 发生改变时，浏览器需要重新计算样式和渲染树，这个过程比较消耗性能。
- 重绘：指元素的外观样式发生变化（比如改变 背景色，边框颜色，文字颜色 color 等 ），但是布局没有变，此时浏览器只需要应用新样式绘制元素就可以了，比回流消耗的性能小一些。

所以，回流一定引起重绘，但重绘可以单独进行。注意字体大小改变属于回流。

### 存储

## node

### 本质

一种环境，相当于一个中间人，能够识别 js 语言，并且能够指挥电脑进行工作。

### 作用

- 可以运行在服务器，而 js 又能运行在 node 环境中，所以可以使用 js 来才操作服务器，使 js 能够项 java 一样处理后端逻辑，由此让前端人员可以轻松的编写后端代码。
- 可以创建电脑命令工具，由此可以通过命令行进行 js 库的管理，实现 js 库发布，下载等操作。
- 本身支持 js 模块化，使得 js 可以进行模块化开发，大大提高前端开发得效率。

## webpack。

模块化打包工具。实际上就是一个 js 库，所以能够在 node 中运行。当 webpack 的 js 执行的时候，node 识别到这些 js 命令，然后 node 调用电脑执行对应的操作而已。所以 webpack 实际就是通过 js 调用电脑资源分析对应的文件数据，将这些文件数据转换成浏览器能够认识的文件数据。

## HTML 代码执行顺序

- 自上而下执行 html 标签。
- 如果遇到 link 标签会异步下载对应 css，然后继续向下解析 dom。
- 如果遇到 script 标签会执行 script 标签内的 js 或下载对应的 js 并执行，执行之后再解析下一个标签。如果 script 标签下载好之后，之前有 css 标签资源未下载完成，则会等待 css 加载完成后才执行。
- 标签解析完后生成 dom 树。
- 等待 css 解析完成生成 css 树，然后合成 render 树。
- 最后 Gui 线程渲染 render 树的信息。

浏览器的下载线程和 GUI 线程是同时进行的，就是说在渲染过程中可以同时进行 js 等资源的下载。window.onload 再所有资源加载外后再执行。$(document).ready()再 dom 结构渲染完后执行。

## 前端代码转换流程

- 编写 es6、react、vue 等代码
- 在 node 开发的命令行工具执行对应的命令
- node 识别该命令行命令后指挥电脑执行前端打包工具库(webpack 等)内对应的 js 代码
- node 再次识别 webpack 内对应的 js 代码后指挥电脑对对应文件数据进行处理
- 最后生成能够被浏览器运行的文件数据。

## 全局安装

如果全局安装，则在电脑的每个文件目录下的命令窗口都能访问到该命令

## js 模块化

- 历史上 js 官方一直没有模块化的能力，所以 ES6 之前一些社区通过开发 commomJS 和 AMD 来实现 js 的模块化，前者主要用于服务器，后者用于浏览器。ES6 之后 js 的提供的 ES 模块化可以支持在浏览器和服务器运行。
- 所以模块化即将本该写在一个文件内的 js 代码，我们开发的时候将其写成若干 js 文件以便于开发。而打包工具在打包过程中会对这些 js 文件进行分析，将有些文件进行合并，有些继续保持单文件。
- 项目入口 html 被浏览器识别后通过标签下载执行 js，当我们下载的 js 是由模块化打包的文件，那么在执行这个 js 时，会不断的自主下载关联的模块 js 文件(以前是通过 AMD 的 api 下载，现在可以直接使用 ES 的语法下载)。

## 模块化 js 执行

模块化的 js 在被运行环境(浏览器引擎或 node)解析后，运行环境再次解析到引入该模块的命令时，该模块内的代码不会被再次执行,如果引入的时候路径的参数发生变化，那么会重新执行该模块并形成一个新的缓存而不是覆盖上一次加载该模块生成的缓存。

### commomJs

node、browserify 等工具使用了规范

### AMD

浏览器使用了该规范

### CMD

### ESmodule

浏览器采用了规范

### 懒加载

只加载当前页面能够显示的效果，剩下的效果等待人为触发后再加载。

## unicode 和 ASCII

两者都表示字符在磁盘中存储的二进制数据，只是我们习惯将其对应的数据转化成十进制数字进行理解。ASCII 码对应的只有数字、英文字母、空格等字符的数值。而 unicode 对应着全球所有字符的二进制转换数值。当然，不同国家有自己的解析方式，同一个字节的二进制可能在不同国家对应的字符不一致，所以出现了不同解码方式。

## 转义字符

譬如换行字符在键盘输入该字符后，磁盘内会将其存为\和 n 的二进制，当解析器解析到\n 时，显示器就会显示成换行的效果，由于\作为了转义标识符，所以输入\后会在磁盘中连续存入两个\字符的二进制数据以达到转义的目的。

## 函数上下文(this)

是函数执行时默认传入的一个参数，由此 this 是执行上下文的一部分。

## 函数执行上下文(调用帧)

函数在执行时，会产生一个调用帧推入调用栈存储当前函数的变量和调用位置信息，当函数内再次执行函数时，会再次创建一个新的调用帧。当最深层的函数返回之后逐层销毁调用帧。

## 函数柯里化

意思是将多参数的函数转换成单参数的形式。其实就是利用闭包来保存其中某些变量。

## 类数组

诸如 nodeList、arguments 等是一个"object object"类型的对象，只是它的 key 是序号且有 length 属性，所以成为类数组，如果类数组拥有 Iterator 接口，那么可以转化为真实数组。

## 模块的 Singleton 模式

模式指的是调用一个类，任何时候返回的都是同一个实例，对 node 来说，即每次引用该模块会返回相同的数据。

## 垃圾回收

当一个变量不能被访问时，会被垃圾回收机制回收，防止内存泄漏

## 参数求值

js 采用了传值调用

### 传值调用

一个函数传入的参数如果是一个表达式，将表达式进行求值，然后将求值结果传入函数

### 传名调用

一个函数传入的参数如果是一个表达式，将表达式整体传入函数体，用到该参数时再求值。

## Thunk 函数

为了解决传名调用，将参数的表达式写成一个函数的返回值，如此便可以将参数写成该函数，需要用到参数时调用该参数函数就行。而 js 对于 Thunk 函数的定义为柯里化函数，即将多参数函数写成单参数函数。

## cookie

浏览器用于存储验证信息的一小块内存，一般 4kb 左右，保存的信息包括过期时间，请求是否来自统一服务器，用户登录状态等，以此来实现 http 的有状态响应。由此开发时可以通过 cookie 来判断登录情况。
当浏览器建立标签页后，浏览器会自动将服务器发送的 cookie 信息保存起来，之后每一次请求浏览器都会自动携带这些 cookie 信息，不用我们设置。该信息保存在 document 对象上。

## Git

一个版本管理工具，可以很好的帮助我们管理项目代码，并且帮助我们远程合并代码。Git 的合并逻辑是，先通过 add 命令将修改的文件添加在暂存区，然后使用 commit 命令将暂存区的文件合并到本地仓库，再然后通过 push 命令将本地修改合并到远程仓库。

### 分支

每一次 commit 都会在 git 仓库中生成一个版本，而一个分支的指针指向该分支的当前版本。git 的 head 指针指向当前分支，当我们创建分支时，会新增一个指针指向我们创建分支时所指定的版本。当我们切换到对应分支后，head 指针就指向当前分支的指针。最终不同分支的版本会形成一颗版本树，每个分支指针都指向其最新版本。

### 暂存区

暂存区实际就是修改文件的一次快照，有助于我们分类提交代码。不同分支共享同一暂存区，如果在一个分支上修改了文件后加入了暂存区，但没有进行 commit 便立刻切换到另一分支进行 commit，那么就会将上一个分支的代码合入后一个分支。

### 冲突

只有当不同分支合并，本地和远程仓库互相更新时可能会出现冲突，需要进行对比时才有可能出现冲突。

## 贝赛尔曲线

设置一个起始点和结束点，然后为起始点和结束点分别设置一个控制点，通过调整控制点和对应起始点或结束点的距离和角度使得起始点和结束点之间的线段呈现出不同的光滑弯曲程度，ps 中的钢笔工具就是贝塞尔曲线。

## 小程序

各个厂家(微信，支付宝等)的应用基于浏览器搭建了一个解析器，用于解析我们开发的小程序代码，小程序代码可以通过 web 端框架进行开发，不过开发完之后需要通过例如 taro 等框架将 web 端代码打包成解析器可识别的代码。

## h5

就是 web 端应用，可以运行在浏览器和 webview

## webview

各厂商应用基于 webkit 内核开发的一个 web 应用解析器，可以让小程序打开 web 应用。
