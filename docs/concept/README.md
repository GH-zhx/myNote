# 前端概念

## polyfill
用于实现浏览器并不支持原生API的代码。
下面举一个例子：document.querySelectorAll()现在大多数浏览器都已经支持该方法，但是仍然存在一些比较老的版本的浏览器不支持该方法，此时如果写一个库，通过对该库的引用，从而使得浏览器可以和其他浏览器一样使用该方法，此时这个库就是polyfill。

### 已经存在的polyfill
1. polymer:让旧的浏览器可以使用HTML5中的Web Component的polyfill。
2. FlushCanvas：是让无法使用的canvas的浏览器使用canvas。

### polyfill和shim的区别:
一个shim是一个库，它将一个新的API引入到一个旧的环境中，而且仅靠旧环境中已有的手段实现。
一个polyfill就是一个用在浏览器API上的shim。

有两大好处
1. 首屏时间缩短
2. 利于SEO

## urlencoded编码
对应get请求的参数传递格式
```js
"key=value&key=value"
```
## 纯函数
- 同样的输入，得到同样的输出。
- 不得修改传入的参数
- 不调用Date.now()和Math.random等不纯的函数。
- 没有任何副作用，不发送请求等。

## 服务端渲染
SSR (Server-side Rendering)
顾名思义，就是在浏览器发起页面请求后由服务端完成页面的HTML结构拼接，返回给浏览器解析后的HTML，让浏览器能直接构建出有内容的页面。有两个问题：
1. 什么时候开始生成该HTML，猜测是一旦服务器的服务启动了之后就将该HTML生成，而不是等接收到浏览器请求之后再开始生成该HTML。
2. 服务器端生成的是真实的html结构字符串，浏览器直接就可以解析渲染。
3. 浏览器拿到首页html之后的执行顺序猜测：直接解析html并渲染 -> 根据html中的script标签下载js执行，代码执行后，将页面上的dom全部重新替换成由下载的js运行后生成的dom。
4. 服务端渲染框架生成首页html的过程猜测为：框架生成对应的真实html结构，然后为该html添加获取入口js的script标签。

## 浏览器环境和node
浏览器的引擎可以解析js，而node.js是谷歌浏览器的v8引擎进行封装和优化，使得js能够被node解析。

## 浏览器
### 工作原理
浏览器在地址栏输入地址后，浏览器向服务器发送了http请求，然后返回对应的资源，默认返回index.html，当该html文件加载之后，根据该文件的代码，不断向浏览器请求对应的css，js，png等资源，这些资源请求之后被浏览器存储下来并执行。

### 浏览器模块化
- 以前的浏览器的js模块化只支持AMD
- 现代浏览器已经支持了es模块化，但是需要将script标签的type设置为module，这会将js语言环境变为严格模式。
- 如果直接通过盘符打开的html文件来使用es的模块化语法，会有跨域问题，因为此时浏览器路径是盘符路径，已经和js文件所在的盘符地址跨域了。所以需要通过开启本地端口服务器来访问该html，使js文件和html文件在同一域下。
- 如果需要访问浏览器js引擎模块化需要安装requre.js库来实现。

### 浏览器进程与线程
当浏览器新开一个tab页之后，会在电脑上开启一个进程，该进程会有协议，域名，端口号，该进程内包括多个线程，iframe页面也是会新开一个进程。
- GUI渲染线程，负责渲染页面元素，改线程和js引擎是互斥的，当js引擎工作时，该线程是不能工作的，这就是js运行导致页面阻塞的原因。
- js引擎，负责解析js代码。同样当GUI线程工作时，该线程是不工作的。
- 事件触发线程。管理诸如ajax请求，setTimeout等任务。当js引擎空闲时会扫描该线程，该线程按照事件循环的规则将任务队列的一个任务推入js引擎进行执行。
- 定时器触发器进程。对setTimeout和setInterval进行计时。当计时达到了将任务推入事件触发线程，等待js引擎执行。
- ajax请求线程。当请求发起时浏览器开启一个线程请求，等待请求返回后将回调任务推入事件触发线程，等待js引擎执行。

### 浏览器跨域
一个浏览器进程(tab页)的ajax请求向服务器发送请求获得数据后，浏览器会判断服务器的协议，域名，端口与自己是否一致。如果不一致浏览器则不会将返回的信息提供给我们访问。该限制只在浏览器，在服务器之间发送请求是没有跨域限制的。
解决跨域的方法
1. cors 通过后端返回响应头，浏览器在解析这些响应头后，就会让我们能够访问浏览器得到的数据。
2. jsonp，借助script标签的src请求，该请求不属于ajax请求，不会被同源策略限制，但是只能处理get请求。
3. 开启代理服务器，在浏览器所在主机开启一个符合同源策略的代理服务器，ajax请求发送的时候发送给这台代理服务器，然后代理服务器向目标服务器发送http请求，由此我们就可以访问目标服务器返回的数据。
所以整个数据请求流程变成了：ajax请求->代理服务器向目标武器发送http请求->目标服务器返回对应数据->代理服务器接受到数据->代理服务器将接受的数据提供给浏览器->浏览器提供可供js访问的数据。
开启代理服务器有多种方法
- nginx
- vue-cli等脚手架。
配置代理服务器其实就是指设置代理服务器的目标服务器路径，以及将ajax请求路径中携带的标识清除以确保代理服务器请求路径和目标服务器对应的资源路径相同等。

### 浏览器源代码
会显示浏览器根据map文件反编译生成的代码和实际在js引擎中执行的代码。而反编译代码反编译到哪个流程不一致(待研究)，有的情况下反编译至在node中运行的代码，有的情况下反编译至开发时源代码。

### 浏览器控制台
编写的代码被浏览器的js引擎执行。

### 重绘和回流
- 回流（也叫重排）：当 DOM结构发生变化 或者 元素样式 发生改变时，浏览器需要重新计算样式和渲染树，这个过程比较消耗性能。
- 重绘：指元素的外观样式发生变化（比如改变 背景色，边框颜色，文字颜色color等 ），但是布局没有变，此时浏览器只需要应用新样式绘制元素就可以了，比回流消耗的性能小一些。

所以，回流一定引起重绘，但重绘可以单独进行。注意字体大小改变属于回流。

## node
### 本质
一种环境，相当于一个中间人，能够识别js语言，并且能够指挥电脑进行工作。
### 作用
- 可以运行在服务器，而js又能运行在node环境中，所以可以使用js来才操作服务器，使js能够项java一样处理后端逻辑，由此让前端人员可以轻松的编写后端代码。
- 可以创建电脑命令工具，由此可以通过命令行进行js库的管理，实现js库发布，下载等操作。
- 本身支持js模块化，使得js可以进行模块化开发，大大提高前端开发得效率。

## webpack。
模块化打包工具。实际上就是一个js库，所以能够在node中运行。当webpack的js执行的时候，node识别到这些js命令，然后node调用电脑执行对应的操作而已。所以webpack实际就是通过js调用电脑资源分析对应的文件数据，将这些文件数据转换成浏览器能够认识的文件数据。

## HTML代码执行顺序
- 自上而下执行html标签。
- 如果遇到link标签会异步下载对应css，然后继续向下解析dom。
- 如果遇到script标签会执行script标签内的js或下载对应的js并执行，执行之后再解析下一个标签。如果script标签下载好之后，之前有css标签资源未下载完成，则会等待css加载完成后才执行。
- 标签解析完后生成dom树。
- 等待css解析完成生成css树，然后合成render树。
- 最后Gui线程渲染render树的信息。

浏览器的下载线程和GUI线程是同时进行的，就是说在渲染过程中可以同时进行js等资源的下载。window.onload再所有资源加载外后再执行。$(document).ready()再dom结构渲染完后执行。

## 前端代码转换流程
- 编写es6、react、vue等代码 
- 在node开发的命令行工具执行对应的命令 
- node识别该命令行命令后指挥电脑执行前端打包工具库(webpack等)内对应的js代码
- node再次识别webpack内对应的js代码后指挥电脑对对应文件数据进行处理
- 最后生成能够被浏览器运行的文件数据。

## 全局安装
如果全局安装，则在电脑的每个文件目录下的命令窗口都能访问到该命令

## js模块化
- 历史上js官方一直没有模块化的能力，所以ES6之前一些社区通过开发commomJS和AMD来实现js的模块化，前者主要用于服务器，后者用于浏览器。ES6之后js的提供的ES模块化可以支持在浏览器和服务器运行。
- 所以模块化即将本该写在一个文件内的js代码，我们开发的时候将其写成若干js文件以便于开发。而打包工具在打包过程中会对这些js文件进行分析，将有些文件进行合并，有些继续保持单文件。
- 项目入口html被浏览器识别后通过标签下载执行js，当我们下载的js是由模块化打包的文件，那么在执行这个js时，会不断的自主下载关联的模块js文件(以前是通过AMD的api下载，现在可以直接使用ES的语法下载)。
## 模块化js执行
模块化的js在被运行环境(浏览器引擎或node)解析后，运行环境再次解析到引入该模块的命令时，该模块内的代码不会被再次执行,如果引入的时候路径的参数发生变化，那么会重新执行该模块并形成一个新的缓存而不是覆盖上一次加载该模块生成的缓存。

### commomJs
node、browserify等工具使用了规范
### AMD
浏览器使用了该规范
### CMD

### ESmodule
浏览器采用了规范

### 懒加载
只加载当前页面能够显示的效果，剩下的效果等待人为触发后再加载。

## unicode和ASCII
两者都表示字符在磁盘中存储的二进制数据，只是我们习惯将其对应的数据转化成十进制数字进行理解。ASCII码对应的只有数字、英文字母、空格等字符的数值。而unicode对应着全球所有字符的二进制转换数值。当然，不同国家有自己的解析方式，同一个字节的二进制可能在不同国家对应的字符不一致，所以出现了不同解码方式。

## 转义字符
譬如换行字符在键盘输入该字符后，磁盘内会将其存为\和n的二进制，当解析器解析到\n时，显示器就会显示成换行的效果，由于\作为了转义标识符，所以输入\后会在磁盘中连续存入两个\字符的二进制数据以达到转义的目的。

## 函数上下文(this)
是函数执行时默认传入的一个参数，由此this是执行上下文的一部分。

## 函数执行上下文(调用帧)
函数在执行时，会产生一个调用帧推入调用栈存储当前函数的变量和调用位置信息，当函数内再次执行函数时，会再次创建一个新的调用帧。当最深层的函数返回之后逐层销毁调用帧。

## 函数柯里化
意思是将多参数的函数转换成单参数的形式。其实就是利用闭包来保存其中某些变量。

## 类数组
诸如nodeList、arguments等是一个"object object"类型的对象，只是它的key是序号且有length属性，所以成为类数组，如果类数组拥有Iterator接口，那么可以转化为真实数组。

## 模块的 Singleton 模式
模式指的是调用一个类，任何时候返回的都是同一个实例，对node来说，即每次引用该模块会返回相同的数据。

## 垃圾回收
当一个变量不能被访问时，会被垃圾回收机制回收，防止内存泄漏

## 参数求值
js采用了传值调用

### 传值调用
一个函数传入的参数如果是一个表达式，将表达式进行求值，然后将求值结果传入函数

### 传名调用
一个函数传入的参数如果是一个表达式，将表达式整体传入函数体，用到该参数时再求值。

## Thunk函数
为了解决传名调用，将参数的表达式写成一个函数的返回值，如此便可以将参数写成该函数，需要用到参数时调用该参数函数就行。而js对于Thunk函数的定义为柯里化函数，即将多参数函数写成单参数函数。

## cookie
浏览器用于存储验证信息的一小块内存，一般4kb左右，保存的信息包括过期时间，请求是否来自统一服务器，用户登录状态等，以此来实现http的有状态响应。由此开发时可以通过cookie来判断登录情况。
当浏览器建立标签页后，浏览器会自动将服务器发送的cookie信息保存起来，之后每一次请求浏览器都会自动携带这些cookie信息，不用我们设置。该信息保存在document对象上。

## Git
一个版本管理工具，可以很好的帮助我们管理项目代码，并且帮助我们远程合并代码。Git的合并逻辑是，先通过add命令将修改的文件添加在暂存区，然后使用commit命令将暂存区的文件合并到本地仓库，再然后通过push命令将本地修改合并到远程仓库。暂存区实际就是修改文件的一次快照，有助于我们分类提交代码。